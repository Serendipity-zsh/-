**题目：**

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

> **输入:** [2,2,1]
>
> **输出:** 1

**示例 2：**

> **输入:** [4,1,2,1,2]
>
> **输出:** 4

**思路方法：**

这道题相对来说比“存在重复”是稍微难一点的，这道题我暂时没有想出来比较简单的算法，我的方法还是按常规思路来解决的。

我们的目的就是找出数组中那个没有重复的元素，“存在重复”那道题只是判断而已，虽然只是多加了一个条件，但是我在实现代码的时候并不是那么容易。我的想法是这样的：让数组中的每一个元素与出本身外的其他元素都比较一遍，同时设定一个bool型的二维数组，行数为数组元素个数（表示每个元素对应一行），列数为行数减一（表示每个元素的每次比较），在比较过程中如果两个元素不相等，那么就让bool二维数组对应行列的元素置为true，否则置为false。这样全部比较完成后，那个数组中不重复的元素对应的一行全部都为true，所以再用一个循环，判断bool型二维数组中每一行的true个数，这里同时还要设置一个整型数组，大小跟输入数组大小相等，而且元素都置为0，这个数组就记录bool型二维数组中每行true的个数，最后找出这个数组中数值为bool型列数的下标值，这个下标值即为输入数组中那个无重复元素的下标，返回输入数组中的这个下标值对应的值即可。

**代码如下：**

```cpp
class Solution {
public:
    int result(vector<int>& nums) {
            int n=nums.size();         //size()函数返回数组nums的大小
	    bool judge[n][n-1];
	    int sum[n];
            for(int i=0;i<n;i++)
            {
                sum[i]=0;
            }
            for(int i=0;i<n;i++)
	    {
                int list=-1;
		for(int j=0;j<n;j++)
		{
		    if(i!=j)
                    {
                       list++;
		       if(nums[i]!=nums[j])
		       {
                           judge[i][list]=true;
		       }
                        else
                        {
                            judge[i][list]=false;
                        }
                     }  
		 }
	     }
	     for(int i=0;i<n;i++)
	     {
	          for(int j=0;j<n-1;j++)
		  {
		        if(judge[i][j]==true)
			{
				sum[i]++;
			}
		  }
	      }
	      for(int i=0;i<n;i++)
	      {
		   if(sum[i]==n-1)
		   {
			return nums[i];
		   }
	      }
    }
};
```