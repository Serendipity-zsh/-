**题目：**

给定一个 32 位有符号整数，将整数中的数字进行反转。

**示例 1：**

> **输入:** 123
>
> **输出:** 321

**示例 2：**

> **输入:** -123
>
> **输出:** -321

**示例 3：**

> **输入:** 120
>
> **输出:** 21

**注意:**

假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2的31次方,  2的31次方 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。

**思路方法：**

这道题我的方法依旧是比较笨，思路就是先要把输入的整数的每一位上的数字分离出来，因为涉及多个数字，所以就考虑用数字来记录，这个自然也是需要有顺序的，就按照输入整数的位数从小到大，就是从个位开始。记录好之后就要从数组的第一个数开始乘以10的n-1次方，这里的n表示数组的大小，后面的数乘以10的次方数依次减少，然后把这些数相加，就得到结果了。对了这里有一个点，就是为了排除输入整数的正负号影响，我就先把它调整为整数了，到最后再恢复，详细的看下面的代码，还有需要注意的是，输出整数的范围，在最后附加一个判断就可以了。

**代码如下：**

```cpp
class Solution {
public:
    int reverse(int x) {
        vector<int> nums(10);     //2的31次方为10位数，所以这里创建一个大小为10的数组
	int i=0; 
	long sum=0;              //用来记录最后的结果
	int temp;                //temp用来记录输入整数的正负
	if(x>0)
	{
	    temp=1;
	}
	else
	{
	    temp=-1;
	    x=x*(-1);
	}
	while(x)
	{
		nums[i]=x%10;
		x/=10;
		i++;
	}
	for(int j=0;j<i;j++)
	{
		sum+=nums[j]*pow(10,i-1-j);    //pow(m,n)函数表示的是m的n次方
	}
	sum*=temp;
        if(sum>pow(2,31)-1||sum<(-1)*pow(2,31))
              return 0;
        else
              return sum;
    }
};
```

